package chapter07;

/**
 * @Author MPC
 * @Description:
 * @Date Created in 17:46 2020/5/23
 * 第七章 复用类
 *  * 对于已存在的类可以重复利用代码
 *  * 方法一：在一个新类中，通过创建已有类的对象来调用原有类的属性；二者成为组合，是has-a的关系；
 *  * 方法二：根据已有的类，创建该类的衍生类，称为继承；是 is-a 或者is-like -a的关系；
 *  * 方法三：在一个类的方法参数列表中接受其他类对象的引用；这是弱关系，是use-a的关系
 *  *组合比较简单，只要在一个类中引用另一个类就好；
 *  每一个非基本数据对象都需要重写toString方法；使得对象不再是一个地址值；
 *  一个类加载先看成员变量是否有静态的对象创建；没有则从main方法开始逐条执行；还是注意；静态只执行一次；
 *
 *  继承语法为extends关键  子类会继承父类的方法和属性，是所有的；
 *  在同一个源文件中，父类和子类同时拥有main方法，优先调用父类方法；若二者都想调用，可以
 *  显示的调用命令行  类名.main（args）；
 *  命令行是 java 字节码文件名
 *  为了继承 将所有类的变量设为私有的，方法变为共有的；
 *  子类中调用父类的方法用super关键字，构造方法则是super();
 *  子类继承了父类的所有方法；这就是说二者公用接口；
 *  子类创建一个子类对象，其中包含了一个父类对象；在其内部；
 *  所以必须要对基类子对象进行初始化；这就是需要调用父类的构造器；
 *  java会自动的默认的在子类的构造器中添加父类的构造器；（这是暗地里，默许的，不需要人为操作）
 *  所以对子类对象初始化时，先对其基类对象初始化；
 *  以上都是无参数的自动地调用；
 *  如果是有参数的构造器，需要人为的使用super来调用在第一行，否则会编译报错；
 *
 *  第三种关系代理，间接的组合；
 *  代理模式的关键点是:代理对象与目标对象.代理对象是对目标对象的扩展,并会调用目标对象
 *  代理的好处，可以使用所需要的目标对象的功能，没必要全部使用，或者可以扩展目标对象的功能；
 *  这比组合和继承要更加的灵活；
 *
 *  对于组合继承的合体是用，一定要注意初始化得书序；
 *  main方法所在的类加载，先是静态的对象，再试静态的main，遇到子类初始化，一定要先加载父类；
 *  方法的重写是父类子类中的方法签名一致，返回值一致或者有继承关系；
 *  方法的重载主要是方法的名称一致，其余都不同，父类子类的可以出现方法的重载，二者之间没有屏蔽；
 *
 *  组合继承的选择;
 *  组合主要在新构造的类中使用现有类的功能，而非现有类的接口；
 *  在新构造的类中使用private嵌入对象，使其获得功能，而非全部接口；
 *  使用想法：有一个使用组合，是一个或者像一个使用继承关系；
 *
 *  修饰符protected对包内以及子类是可以访问的；对于用户使用者来说这是私有的
 *  继承中的多态的核心就是向上转型，可以认为子类是一个父类；所以任何时候都可以转型成功；
 *   如果需要向上转型，就可以使用继承关系，如果用不到就使用组合关系；
 *
 *   关键字final是无法改变的意思
 *   final修饰数据的时候，这就是一个常量，一旦创建，就不能更改；
 *   一般Math的pI和E就是常量；
 *   如果是static final 修饰基本类型；对于该类来说，常量只是被初始化一次，所用的对象懂不能够改变这个值；、
 *   如果不加入static，意味着每个对象都有一个不可变的常量值；（适用于非直接复制，随机赋值）
 *   final修饰引用时就将该引用和对象进行了绑定，不能再指向别的对象了；
 *   对于static final修饰的常量要用大写加下换线的形式；
 *   空白final表示对final修饰的变量并不是一次初始化；而是在构造器中初始化；
 *   这样保证了不同对象的不同不变值得设定；
 *
 *   final修饰参数列表，意味着形参不能再方法体内修改引用指向的对象；
 *   对于基本数据类型来说，只读不修改，例如i++就不行；不要带有i参与的运算;
 *   对于内部类有很多引用；
 *
 *   final修饰方法;锁定方法，主要是方法子类的重写，但是对于重载并没有效果；
 *   对于不想覆盖的方法，就是private final的；private可以省略；final也可以省略，二者得1即可‘
 *  判断方法是否为覆盖方法，就是将对象向上转型为基类对象，并且能调用相同的方法；
 *  覆盖的方法是基类的接口一部分，但是private的方法就是类中的接口，只是隐藏域类中；
 *  如果基类的private final方法在子类生成一个public protected或者默认的额方法；
 *  此时子类的方法就不是覆盖方法，而是一个新方法！
 *
 *  fina类不可继承，进而他的方法和变量都是不可变的，都是final；
 *
 *  类的加载有两个触发调价，一个是创建该类的实例对象，一个是访问该类的静态变量；
 *  static的修饰的变量或者会按照顺序一次加载，完事才是普通变量，完事才是构造器；
 *
 *   类加载的顺序以及初始化
 *   类首先加载由于访问到静态变量，手下一次访问基类子类的静态变量，再一次访问非静态成员变量
 *   和构造器；
 *   注意：静态方法首先需要全部加载完成，在分别加载基类和子类中的额其他初始化；
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
public class Think07 {
    public static void main(String[] args) {
        System.out.println();
    }
}
