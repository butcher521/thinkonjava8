package chapter15;

/**
 * @Author MPC
 * @Description:
 * @Date Created in 14:36 2020/5/30
 *
 * 第15张 泛型
 * 为了使类和方法的使用更加的宽泛化，出现了泛型；以前都是Object代替的；泛化的类型，多态也算是一种；
 * 一般都在方法的参数中使用接口来解除限制，很更多的实现类可以使用；但是很是有显示；
 * 泛型的使用最开始为容器类可以容纳不同种对象，而因为向上转型丢失确切的类型；
 * 一个类可以持有的对象的类型主要是包含在成员变量中，多个持有最好使用泛型类进行约束；
 *泛型用来确定此时类中可以储存同一种元素即可！
 * 想要存入什么样的类型，在泛型中写入即可，泛型可以和继承多态不冲突，可以放入泛型类的子类或者父类；有特殊的语法；
 *
 * 概念：元组（tuple）： 将一组对象直接打包存贮在一个单一对象中
 * 注意;私有的成员对象变量 写作 public final 也是一样的额，阻止了对象引用的乱复制现象！
 * 只读不写，而私有变量时不读不写！ 二者得结果是一样的！！
 * 想要扩大元组的长度只需要继承，将扩展的元素写在成员属性中，在构造器中调用次元素即可；
 * 注意：在模范中没有确定泛型中的类是什么，只是一个占位符而已；
 * 例如Tuple<A,B.C>这三个类都没有定义，只是说明这个类可以存储三个类型的对象！这类似与常见的占位为T；
 *
 * 泛型用在接口或者类上时，使得此类可能容纳这个泛型，作为容器；
 * 泛型常用作接口，作为生成器，这类似与工厂设计模式！或者适配器
 * 生成器就是一个带有泛型的额就，其中的方法next生成实现这个接口的类或者其他的要求；
 * 裴波那契数列，n=3开始 fn=f(n-2)+f(n-1)  一般递归实现！
 *
 * 泛型的局限：只能添加引用和类型，基本类型要拆装箱！
 * 如果不想修改源码，使用适配器，继承源码，实现新的接口功能即可！
 *
 * 泛型服务于方法
 * 竟可能的将泛型应用于方法中，这样更能说明问题；静态的方法无法访问泛型的类型；
 * 只要将泛型参数列表方法在返回值前面即可  例如 public <T> void f(T t){}
 * 泛型方法在返回值前面声明后，可以在参数列表中防止任何类型的数据，基本或者引用类型；
 * 注意：必须提前申明，否则会报错，认为这是一个没有的类！
 * 编译器或根据我们放入的参数进行参数类型的推测！
 * 注意：类型推断不止是对于赋值操作有用，对于参数方法中调用方法也是可以蚀变的
 * 显示的类型说明，调用方法时，在点和方法之间加入尖括号显示的说明泛型;
 * 这就是直接在生成的时候声明了泛型的类型！
 可变参数类型就是 在参数类型和参数引用之间加入三个小数点,这就是代表一个参数可变的数组，可以使用迭代器遍历；

 一个巧妙的异常抛出：在catch语句中，使用基类异常接受，并把它抛到运行异常中！
静态的导包，类中的额静态方法可以直接使用；比如枚举类；

 泛型引用于匿名内部类：
 擦除：在泛型的内部，是获取泛型的参数类型，只是简单的占位符；对于同一个的不同泛型参数，编译器认识他们的Class对象相等；
 将参数类型擦除，只是剩下一个原生的类型；
 泛型的通配符有两种  ? extends 父类；这就是被为不能直接向上转型的设立的；
 还有一种逆变   ？super 子类 ；类型是任何子类的父类！

 *
 *
 *
 *
 *
 * 
 *
 *
 */
public class Think15 {
}
