package chapter05;

/**
 * @Author MPC
 * @Description:
 * @Date Created in 9:48 2020/5/23
 *
 * 第五章 初始化
 * 使用构造器进行初始化，在使用对象之前，通过构造器对对象进行初始化；每次创建对象的时候，会自动的初始化；
 * 对象的创建：为对象在堆内存中分配空间；调用构造器对其进行初始化；
 * 构造器是和类名同名；有两种，有参与无参；这就是方法重载的方式完成的；
 * 方法的重载 就是主要是参数列表的变化（顺序变化，数量变化等），返回值可变可不变；这也是区别的方式；
 * 参数列表的参数是形式参数，传入的参数是实际参数；
 * 对于基本数据类型的重载，如果实参的范围小于形参，会自动的提升为形参的等级；
 *
 * 如果没有申明构造器，系统弧自动的生成一个无参构造器；如果自己创建，就不会生成；
 * 关键字this 就是方法内部获取的当前对象的引用；这个当前对象就是当前类的实例；
 * this关键字只能在方法的内部使用，作为一个对象的引用；
 * 如果当前类的一个方法强调用此类的另一个方法就可以省略了；
 * 这个引用可以调用方法，变量，可以直接只用；
 * 构造方法的调用必须是第一个的第一个代码写入this（参数列表）；
 * 比如多加一个参数，就没必要重写在一堆；一个构造器中只能定一个一个，必须放在第一行；
 *
 * Static方法的内部不能直接调用非静态方法；如果是对象调用还是可以的；
 * 静态属于类，非静态属于对象；需要创建对象，才能调用费静态方法；
 *
 * 成员的初始化：成员变量时自动初始化的，局部变量不初始化就不能调用；
 * 基本数据类型的初始化有0,0.0，false，/u0000，对象的初始化都为null；
 *
 * 构造器的初始化
 * 成员变量的自动初始化优先于构造器初始化，因为构造器在创建对象是才会被初始；
 * 成员变量的初始化顺序取决于定义的顺序，但是仍然早于包括构造器的任何方法被调用；
 * 注意：程序的执行从main方法处入手，非静态方法除非手动调用，否则不会初始化；
 * 一般创建对象，初始化顺序为：类的成员变量，类的构造器；
 * 先看main方法的类有没有静态初始化，有则访问静态，没有才依次执行main中的方法；
 * 主要成员变量中是否有新创建的对象，否则只关注构造器就好！
 *
 * 静态数据的初始化：
 * 静态变量在只占有一个内存空间，所有的对象共享，且只初始化一次；
 * 不能用来修饰方法内部的局部变量；
 * 静态数据的加入，初始化得顺序为静态成员变量，非静态成员变量，构造器；注意，静态的变量只初始化一次；
 * 当首次创建某个类的对象，或者访问某个类的静态属性时，执行初始化该类的全部初始化；静态执行一次；
 * 静态代码块为多个静态初始化提供了显示的表达；
 *
 * 数组就是一个装有同一类型的引用的容器；
 * 可变参数列表实际上就是传递一组数组元素；注意，必须在参数列表的使用；
 * 这个常和for迭代连用；
 * 枚举类型实际上就是一个类，类中保存着一组常量集合；
 * 枚举类的方法 values返回常量的数组形式， ordinal 返回元素的索引顺序；
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
public class Think05 {
}
