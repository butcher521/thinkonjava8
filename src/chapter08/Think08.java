package chapter08;

/**
 * @Author MPC
 * @Description:
 * @Date Created in 11:03 2020/5/24
 *
 * 第八章 多态
 * 多态将接口和实现分离，将做什么和怎么做分离；使得代码可读性变高，扩展代码方便；
 * 封装就是将属性和方法封装到一个类中，这个类就是抽象数据结构；
 * 将对象当做他本身基类的对象来使用，就是所谓的向上转型；
 * 常见，一个方法的参数接受一个基类的对象，可以给他传递一个子类的对象引用
 * 此时自动的向上引用；实现多态；
 * 没过没有多态，要为每一个子类的添加一个新的方法来接收他们自己的对象引用；很麻烦；
 * 子类如果多的话，多态就是很好的选择，简单；
 * 多态的实质就是代码只和基类打交道；
 * 通过子类对象携带的信息，可以知道运行的时候到底运行哪一个方法，这个只有运行时才能知道
 * 编译期是不清楚，这就是叫做动态绑定；
 * java中除了静态方法和final的方法，否是后期动态绑定的额方法；
 * 发送消息给对象，由对象自己断定应该做什么事；
 * 简单的语法  基类 基类引用=new 子类（）；基类的指向了子类的对象；
 * 改变的是子类得扩展，不变的是基类引用的调用；
 *
 * 覆盖方法的缺点：private方法就是final的，注定是对子类屏蔽；
 * 所以如果在子类中出现于基类相同的额方法，那就是两个方法，不是重写；
 * 缺点： 多态的实现只有非静态方法：如果是静态方法或者是成员变量，就不适用；
 * 以内多态的运行期后期绑定，而这两个都是编译器解析的；
 * 但是一般成员变量的都设置为私有的，一般不会碰到这个问题；
 * 注意静态方法和类先关，而多态和对象先关；
 *
 * 构造器是隐式的static方法，也是不具有多态的特性；
 * 每一个基类构造器在子类构造器带哦养的同时，强制的对基类对象初始化，因为对象的构造是有顺序的；
 * 对于存在基类，子类，成员为对象引用，有静态成员的情况；初始化的顺序为；
 * 父类静态成员-子类静态成员-父类非静态成员-父类构造-子类非静态成员-子类构造器；
 * 如果父类构造构造器有一个在子类被覆盖的方法，方法中显示的是子类已经赋值的成员变量；
 * 创建子类对象的是，先调用这个父类构造器，其中覅用子类覆盖的方法，方法的显示的子类成员变量
 * 的值是0而不是已经在子类中初始化的；因为此时，子类还没有加载，最开始所有的都是0；
 * 结果，尽量不要在不符合多态的方法中调用多态方法！会出错！；
 *
 * 对于返回值来说，父类子类的方法覆盖中循序返回值类型不同，前提是父类返回值的类型是子类返回值的父类！
 * 状态模式： 利用继承表达行为的不同：不同的子类有不同的方法；
 *           利用字段表示状态的变化：将多态的对象设为成员变量，通过组合方法修改状态；
 *   继承有两种状态： isa 基类子类的方法一致，只是全部覆盖重写     继承接口
 *                  islikea  子类扩展了基类的方法！扩展接口
 *       如果子类扩展了接口，这些扩展了的接口，我们就没有办法通过向上转型来调用了；
 *       因为此时多出来的方法表示，子类不在全部是一个基类的；
 *  向上转型会丢失某些具体信息；向下转型可以获取具体的类型信息；但是要做类型判断；
 *  向上转型是安全的的，因为子类一定是父类，好比圆形一定是形状；
 *  但是向下转型就不一定了，需要进行类型判断；关键字 instanceof
 *  这叫做运行时类型识别；rtti
 *  对于多态  只要是引用类型属于分类，这就是父类的引用；编译只看左边；
 *  父类的调用子类的扩展方法，需要向下转型；前提是这个是子类向上转型后的父类，他才能转型回去；
 *
 *
 */
public class Think08 {

}
