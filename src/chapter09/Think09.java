package chapter09;

/**
 * @Author MPC
 * @Description:
 * @Date Created in 16:35 2020/5/24
 *
 * 第九章 接口
 * 接口和内部类提供了接口实现类分离的更加接口化的方法；
 * 抽象类的接口和类的中庸之道；
 * 抽象了就是将通用接口（抽象方法，做什么）的高度抽象化，
 * 具体的实现(具体方法：怎么做)在他们的实现类或者说导出类中；
 * 不同的子类有不同的实现方式；接口就是子类们的方法的共性抽取；
 * 抽象类和实现类仍旧是继承关系；通过extends关键字实现；
 * 创建高度抽象的基类没有意义，所以会编译报错；
 * 抽象方法就是抽象类的灵魂：语法 abstract 方法名();  注意没有方法体：
 * 包含抽象方法的类一定是抽象类，实现类必须要覆盖重写所有的方法；否则仍旧是抽象类；
 * 当然，抽象类可以没哟抽象方法；注意在抽象类的前面加上abstract关键字；
 * 获取可以再一个类加上抽象关键词限定，这样就可以组阻止这个类产生任何实例对象；
 * 注意；虽然不可以生成抽象类或者接口的对象，但是可以构建他们的引用类型；使用以多态；
 *
 * 接口 是由关键字 interface定义的 ，有implements 关键字实现的；
 * 接口提供了一个完全抽象的类，不同于抽象了可以有局部的不抽象；
 * 接口就是类的协议，规范，模型；规定了类可以使用哪些方法；
 * 接口除了抽象方法外，还可以含有静态不可改变的常量变量；默认为static final的；
 * 接口就是一个骨架，具体怎么长肉还需要实现类自己操作；
 * 为了是接口中的方法用途管饭，默认方法就是public abstract的；
 * 接口中没必要出现Object类中含有的额方法；比如toString之类的，因为默认都继承该方法，且必须重写；
 *
 *策略设计模式：能够根据传递的参数对象的不同而具有不同的行为；
 * 利用继承，使得子类可以有多种实现；创建方法，参数为多态的形式，为父类的引用；
 * 传递的参数就可以是不同子类的对象；就是实现了多态的策略；
 *
 * 为了实现代码的复用最好依据接口实现自己的类，必要的时候可以解除抽象类来过渡；
 * 策略模式是自己创建自己的接口，来进行不同的实现；
 *
 * 如果接口时已存在的，设计好的额；我们可以适配器设计模式来根据已有的来创建自己的接口；
 * 在构造器中接受你已经拥有的接口，利用代理生成你需要的接口对象；
 *
 * 接口不仅是一种更加纯粹的抽象类，接口没有任何具体的实现，可以实现多重继承关系；
 * 多继承的语法; 实现类 extends 基类 implements 接口1，接口2，……{}
 * 方法的参数为接口的引用，使得可以传递所有接口的实现类，使得代码的扩展更加容易：
 * 这一期都要归功于多态的存在；使得可以实现类可以向上转型为多个实现类；
 * 接口也是防止类程序员建立此接口的对象实例；
 * 如要要建立一个不戴任何方法定义和成员变量的基类，优先选择接口；抽象类的等级比接口更具体一点；
 * 接口之间的继承：语法 interface 接口名 extends 其他接口；可以多继承
 * 接口见的继承扩展了接口；
 * 如果要一个实现类要集成多个接口，多个接口中的方法最好不要同名，否则混淆；
 *
 * 适配接口： 一个接口拥有多个不同的实现；
 * 常见形式：方法的参数为某一个接口；具体的实现取决于传递的接口实现类的对象引用类型；
 * 这就是典型的策略模式：接受不同的对象，可以实现不同的方法
 * 将一个现有的类可以创建一个适配的类；适配的继承了现有的类并实现类某个已知的接口；
 * 可以再现有类中添加任何接口；意味着如果某个方法接受接口就可以，就可以让任何实现类来对这个方法
 * 进行适配；
 *
 * 接口中任何变量都是public static final的；
 * 以上的特性可以使用枚举类来实现；当接口被访问的时候，这些变量就只是初始化一次；
 *
 * 接口可以嵌套在类中或者其他接口，类似于内部类；
 * 嵌套字内部的类或者接口如果是private的，这只能被类的唯一外部类所访问，外界不能访问；
 *
 * 生成某一个遵循某个 接口的对象的额典型方式就是工厂方法；这不同于构造器的直接抵用；
 * 在工厂对象上调用创建方法，生成接口的某一个实现类的对象；
 * 说白了，某个接口的工厂就是为了获取接口的实现类而创建的接口；这样这样似的接口和实现类分离；
 *
 *
 *
 *
 *
 */
public class Think09 {
}
