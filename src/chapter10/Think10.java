package chapter10;

/**
 * @Author MPC
 * @Description:
 * @Date Created in 13:22 2020/5/25
 *
 * 第十章 内部类
 * 就是嵌套类，讲一个类放在另一个类的里面；
 * 内部类不同于两类的组合关系；内部类了解外部类的一切，并且能和他通信；但是外部类就不是这样；
 * 如果在外部类的非静态方法除外的地方（静态方法和其他），如果要创建内部类的额对象
 * 一定套通过外部类的对象来调用，声明引用的时候一定是外部类.内部类的格式；
 * 内部类的对象要考外部类的对象来创建（在非静态方法中），所以内部类的对象会有一个指向外部类的连接；
 * 这一切都是对非静态的内部类而言；
 * 使得内部类对象可以随意的访问外部类的成员；注意：是所有元素的访问权，包括私有；
 * 迭代器设计模式：接口中有抽象方法；是否还存在下一个元素，获取元素
 * 将该迭代接口的实现类作为集合类的内部类，外部类调用该内部类实现迭代；
 * 可以再外部类中设立一个工厂方法返回内部类的对象或者内部类的接口；
 *
 * 在内部类中获取外部类的引用的写法：  外部类.this，或者new 外部类；
 * 记住，在外部类的静态方法中（主要在main中）创建外部类的额对象一定要通过外部类的对象来调用；
 * 此时内部类有了外部类对象的隐藏连接；
 * 如果是静态嵌套类，这就不需要外部类的对象了，可以直接创建内部类对象；
 *
 * 向上转型为此对象的基类，等于 实现了某个接口的对象，获取改接口的引用；
 * 如果内部类是某个接口的实现类，内部类就大有用途；
 * 再次提示：接口的所有属性注定是public，变量时static final
 * 对于私有的内部类，只有外部类才可以访问！！这样完全隐藏了内部测实现的细节
 * 但是外部类想要访问内部类的私有变量，还是需要以自己的对象来调用；只是其他类不可以访问；
 *
 * 成员内部类一般就比较简单，
 * 在方法体，或者作用域内部（也是在方法的内部）的定义内部类就有很多玄妙的事情
 * 理由：实现某了接口，可以创建并返回这个接口的引用，这借助了多态的向上转型；
 * 创建一个类辅助，但是不想让这个类被别的类所使用；因为方法内的类只有方法才能访问；
 * 以上的内部类叫做局部内部类；访问的时候只能通过方法来方法，多为返回值；
 * 匿名内部类是局部内部类的一种，这将对象的创建和类的定义放在了一起；
 * 多用于方法的返回值是某一个需要自定义重写de类；
 * 如果是该类的定义没有参数的构造器，系统会默认的给一个；
 * 如果是有参数的构造器，直接在方法的参数类中将参数传递给构造器即可；
 *
 * 如果定义一个匿名内部类，并且希望他是用一个再起外部定义的对象，就是方法中传递一个对象引用；
 * 编译器要求这个参数的引用时final的，即引用不可以更改指向的对象；强制要求；
 * 注意：匿名内部类没有命名的构造器（因为匿名），可以通过实例初始化操作；
 * 匿名内部类的缺陷：对于接口和类的扩展，都是单继承关系！！！
 * 匿名内部类的一大用途就是可以直接写出实现类！不必要说出引用和命名；
 *
 * 嵌套类; 就是申明为static的类，这样内部类的对象创建就和外部类没有任何关系；
 * 这样嵌套类的对象就不能访问非静态的外部类的对象，因为二者之前的连接断了；
 * 普通内部类不能包含静态的属性；但是嵌套类可以；嵌套类还可以有嵌套类；
 *
 * 接口中可以包含嵌套类，接口的任何类都是自动为public static的；
 * 嵌套类升值可以扩展该接口！
 * 如果要在一个类中写一个main方法测试，最好写进去一个嵌套类public static class Test{}
 * 内嵌类不显示在源代码中，一边是外部类%内部类；
 * 嵌套类可以多次循环套用，但是每一个嵌套类都能随意的访问他的外部类！
 *
 * 为什么需要内部类
 * 内部类继承自某个类或者实现某个接口；内部类的代码操作创建它的外围类的对象；
 * 内部类提供了某种进入外部类的窗口；
 * 每一个内部类都能独立的额继承一个接口，成为一个接口的实现；外围类继承的就对于内部类没有影响；
 * 当继承的是类（抽象类或者具体类），就只能通过内部类来实现多继承；
 * 内部类特性：
 * 内部类可以有多个实例，每一个都有自己的状态 ；内外的对象独立存在；
 *
 * 如果想要继承内部类，内部类的构造器连接着外部类对象的引用；
 * 继承内部类，要先让外部类的初始化进行；所以要在实现类中的有参数的构造器中调用外部类构造器的引用；
 * 特殊的语法： 外部类引用.super;
 * 当继承了某一个外围的时候。内部类没有发生什么特别的；
 * 内部类的标识符，外部类$内部类.class；如果是内部类的话就会随机分配数字；
 *
 *
 *
 *
 *
 *
 *
 *
 */